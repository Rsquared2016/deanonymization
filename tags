!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AVERAGE_EACH_CALC	match.hpp	33;"	d
AddWordToVocab	word2vec-read-only/word2phrase.c	/^int AddWordToVocab(char *word) {$/;"	f
AddWordToVocab	word2vec-read-only/word2vec.c	/^int AddWordToVocab(char *word) {$/;"	f
ArgPos	word2vec-read-only/word2phrase.c	/^int ArgPos(char *str, int argc, char **argv) {$/;"	f
ArgPos	word2vec-read-only/word2vec.c	/^int ArgPos(char *str, int argc, char **argv) {$/;"	f
CC	Makefile	/^CC = g++$/;"	m
CC	word2vec-read-only/makefile	/^CC = gcc$/;"	m
CEIL	thpool.cpp	29;"	d	file:
CFLAG	Makefile	/^CFLAG = -O3 -g -pthread$/;"	m
CFLAGS	word2vec-read-only/makefile	/^CFLAGS = -lm -pthread -O3 -march=native -Wall -funroll-loops -Wno-unused-result$/;"	m
CreateBinaryTree	word2vec-read-only/word2vec.c	/^void CreateBinaryTree() {$/;"	f
DEBUG	main.cpp	13;"	d	file:
EXE	Makefile	/^EXE = main$/;"	m
EXP_TABLE_SIZE	word2vec-read-only/word2vec.c	22;"	d	file:
G	match.hpp	/^	class graph * G;$/;"	m	class:matcher	typeref:class:matcher::graph
GAMMA	match.cpp	138;"	d	file:
G_a	match.hpp	/^	class graph * G_a;$/;"	m	class:matcher	typeref:class:matcher::graph
GetWordHash	word2vec-read-only/word2phrase.c	/^int GetWordHash(char *word) {$/;"	f
GetWordHash	word2vec-read-only/word2vec.c	/^int GetWordHash(char *word) {$/;"	f
H	match.hpp	/^	} * H;$/;"	m	class:matcher	typeref:struct:matcher::heap
InitNet	word2vec-read-only/word2vec.c	/^void InitNet() {$/;"	f
InitUnigramTable	word2vec-read-only/word2vec.c	/^void InitUnigramTable() {$/;"	f
L	graph.hpp	22;"	d
LearnVocabFromTrainFile	word2vec-read-only/word2phrase.c	/^void LearnVocabFromTrainFile() {$/;"	f
LearnVocabFromTrainFile	word2vec-read-only/word2vec.c	/^void LearnVocabFromTrainFile() {$/;"	f
MAXLEN	match.cpp	139;"	d	file:
MAX_CODE_LENGTH	word2vec-read-only/word2vec.c	25;"	d	file:
MAX_EXP	word2vec-read-only/word2vec.c	23;"	d	file:
MAX_NANOSEC	thpool.cpp	28;"	d	file:
MAX_NODES	graph.hpp	20;"	d
MAX_ROUNDS	match.hpp	26;"	d
MAX_SENTENCE_LENGTH	word2vec-read-only/word2vec.c	24;"	d	file:
MAX_STRING	word2vec-read-only/word2phrase.c	21;"	d	file:
MAX_STRING	word2vec-read-only/word2vec.c	21;"	d	file:
MULTITHREAD	match.hpp	29;"	d
N	word2vec-read-only/compute-accuracy.c	/^const long long N = 1;                   \/\/ number of closest words$/;"	v
N	word2vec-read-only/distance.c	/^const long long N = 40;                  \/\/ number of closest words that will be shown$/;"	v
N	word2vec-read-only/word-analogy.c	/^const long long N = 40;                  \/\/ number of closest words that will be shown$/;"	v
OBJ	Makefile	/^OBJ = main.o match.o graph.o thpool.o$/;"	m
PRINT_SIMI	match.hpp	23;"	d
ReadVocab	word2vec-read-only/word2vec.c	/^void ReadVocab() {$/;"	f
ReadWord	word2vec-read-only/word2phrase.c	/^void ReadWord(char *word, FILE *fin) {$/;"	f
ReadWord	word2vec-read-only/word2vec.c	/^void ReadWord(char *word, FILE *fin) {$/;"	f
ReadWordIndex	word2vec-read-only/word2phrase.c	/^int ReadWordIndex(FILE *fin) {$/;"	f
ReadWordIndex	word2vec-read-only/word2vec.c	/^int ReadWordIndex(FILE *fin) {$/;"	f
ReduceVocab	word2vec-read-only/word2phrase.c	/^void ReduceVocab() {$/;"	f
ReduceVocab	word2vec-read-only/word2vec.c	/^void ReduceVocab() {$/;"	f
SaveVocab	word2vec-read-only/word2vec.c	/^void SaveVocab() {$/;"	f
SearchVocab	word2vec-read-only/word2phrase.c	/^int SearchVocab(char *word) {$/;"	f
SearchVocab	word2vec-read-only/word2vec.c	/^int SearchVocab(char *word) {$/;"	f
SortVocab	word2vec-read-only/word2phrase.c	/^void SortVocab() {$/;"	f
SortVocab	word2vec-read-only/word2vec.c	/^void SortVocab() {$/;"	f
THPOOL_DEBUG	thpool.cpp	23;"	d	file:
THPOOL_DEBUG	thpool.cpp	25;"	d	file:
THREAD_POOL_SIZE	match.hpp	40;"	d
TrainModel	word2vec-read-only/word2phrase.c	/^void TrainModel() {$/;"	f
TrainModel	word2vec-read-only/word2vec.c	/^void TrainModel() {$/;"	f
TrainModelThread	word2vec-read-only/word2vec.c	/^void *TrainModelThread(void *id) {$/;"	f
USE_ONLY_NEIGHBORS	match.hpp	31;"	d
VocabCompare	word2vec-read-only/word2phrase.c	/^int VocabCompare(const void *a, const void *b) {$/;"	f
VocabCompare	word2vec-read-only/word2vec.c	/^int VocabCompare(const void *a, const void *b) {$/;"	f
_THPOOL_	thpool.hpp	8;"	d
a	ck.py	/^    a = eval(line.split(" ")[0])$/;"	v
all_node_pairs	match.hpp	/^	typedef double all_node_pairs[MAX_NODES][MAX_NODES]; \/\/ x_a, x$/;"	t	class:matcher
alpha	word2vec-read-only/word2vec.c	/^real alpha = 0.025, starting_alpha, sample = 1e-3;$/;"	v
ans_pairs	match.hpp	/^	vector<match_edge> ans_pairs;$/;"	m	class:matcher
arg	thpool.cpp	/^	void*  arg;                          \/* function's argument       *\/$/;"	m	struct:job	file:
b	ck.py	/^    b = eval(line.split(" ")[1])$/;"	v
binary	word2vec-read-only/word2vec.c	/^int binary = 0, cbow = 1, debug_mode = 2, window = 5, min_count = 5, num_threads = 12, min_reduce = 1;$/;"	v
bsem	thpool.cpp	/^typedef struct bsem {$/;"	s	file:
bsem	thpool.cpp	/^} bsem;$/;"	t	typeref:struct:bsem	file:
bsem_init	thpool.cpp	/^static void bsem_init(bsem *bsem_p, int value) {$/;"	f	file:
bsem_post	thpool.cpp	/^static void bsem_post(bsem *bsem_p) {$/;"	f	file:
bsem_post_all	thpool.cpp	/^static void bsem_post_all(bsem *bsem_p) {$/;"	f	file:
bsem_reset	thpool.cpp	/^static void bsem_reset(bsem *bsem_p) {$/;"	f	file:
bsem_wait	thpool.cpp	/^static void bsem_wait(bsem* bsem_p) {$/;"	f	file:
calc_sim_nodes	match.cpp	/^double matcher::calc_sim_nodes(int u, int v, int level) {$/;"	f	class:matcher
calc_sim_nodes_pthread	match.cpp	/^void * calc_sim_nodes_pthread(void * args) {$/;"	f
calc_sim_nodes_wrapper	match.cpp	/^void matcher::calc_sim_nodes_wrapper(int i, int j, bool flag){$/;"	f	class:matcher
cbow	word2vec-read-only/word2vec.c	/^int binary = 0, cbow = 1, debug_mode = 2, window = 5, min_count = 5, num_threads = 12, min_reduce = 1;$/;"	v
center	graph.hpp	/^		int center;$/;"	m	struct:graph::subgraph
classes	word2vec-read-only/word2vec.c	/^long long train_words = 0, word_count_actual = 0, iter = 5, file_size = 0, classes = 0;$/;"	v
cn	word2vec-read-only/word2phrase.c	/^  long long cn;$/;"	m	struct:vocab_word	file:
cn	word2vec-read-only/word2vec.c	/^  long long cn;$/;"	m	struct:vocab_word	file:
cnt1	ck.py	/^cnt1 = 0$/;"	v
cnt2	ck.py	/^cnt2 = 0$/;"	v
code	word2vec-read-only/word2vec.c	/^  char *word, *code, codelen;$/;"	m	struct:vocab_word	file:
codelen	word2vec-read-only/word2vec.c	/^  char *word, *code, codelen;$/;"	m	struct:vocab_word	file:
compare	compare.py	/^def compare(prog_output, correct_pair, num_nodes, output):$/;"	f
cond	thpool.cpp	/^	pthread_cond_t   cond;$/;"	m	struct:bsem	file:
cos_analogy	match.cpp	/^double cos_analogy(double *a, double *b, int len) {$/;"	f
debug_mode	word2vec-read-only/word2phrase.c	/^int debug_mode = 2, min_count = 5, *vocab_hash, min_reduce = 1;$/;"	v
debug_mode	word2vec-read-only/word2vec.c	/^int binary = 0, cbow = 1, debug_mode = 2, window = 5, min_count = 5, num_threads = 12, min_reduce = 1;$/;"	v
debug_print	match.cpp	/^void matcher::debug_print() {$/;"	f	class:matcher
edges	graph.hpp	/^	vector < vector<int> * > edges;$/;"	m	class:graph
expTable	word2vec-read-only/word2vec.c	/^real *syn0, *syn1, *syn1neg, *expTable;$/;"	v
extract_neighbors	graph.cpp	/^vector<int> * graph::extract_neighbors(int node){$/;"	f	class:graph
extract_subgraph	graph.cpp	/^graph::subgraph * graph::extract_subgraph(int node){$/;"	f	class:graph
f	ck.py	/^f = open("R", "r")$/;"	v
f	ck.py	/^f = open("bak_res.txt", "r")$/;"	v
file_size	word2vec-read-only/word2vec.c	/^long long train_words = 0, word_count_actual = 0, iter = 5, file_size = 0, classes = 0;$/;"	v
front	thpool.cpp	/^	job  *front;                         \/* pointer to front of queue *\/$/;"	m	struct:jobqueue	file:
function	thpool.cpp	/^	void*  (*function)(void* arg);       \/* function pointer          *\/$/;"	m	struct:job	file:
gen_ans_pairs	match.cpp	/^void matcher::gen_ans_pairs() {$/;"	f	class:matcher
gen_ans_pairs_iter	match.cpp	/^void matcher::gen_ans_pairs_iter() {$/;"	f	class:matcher
gen_ans_pairs_oldway	match.cpp	/^void matcher::gen_ans_pairs_oldway() {$/;"	f	class:matcher
gen_passage	match.cpp	/^void matcher::gen_passage() {$/;"	f	class:matcher
gen_random_walk	match.cpp	/^void matcher::gen_random_walk(class graph *G, int start, int maxlen, int delta, FILE * ou) {$/;"	f	class:matcher
gen_sim_matrix_simranc	match.cpp	/^void matcher::gen_sim_matrix_simranc() {$/;"	f	class:matcher
gen_sim_matrix_word2vec	match.cpp	/^void matcher::gen_sim_matrix_word2vec() {$/;"	f	class:matcher
graph	graph.cpp	/^graph::graph(const char * file_name){$/;"	f	class:graph
graph	graph.hpp	/^class graph {$/;"	c
graph_hpp	graph.hpp	10;"	d
has_jobs	thpool.cpp	/^	bsem *has_jobs;                      \/* flag as binary semaphore  *\/$/;"	m	struct:jobqueue	file:
heap	match.cpp	/^matcher::heap::heap(class matcher *o) {$/;"	f	class:matcher::heap
heap	match.cpp	/^matcher::heap::heap(int n, int m, class matcher *o) {$/;"	f	class:matcher::heap
heap	match.hpp	/^	struct heap {$/;"	s	class:matcher
heap_down	match.cpp	/^void matcher::heap::heap_down(int x) {$/;"	f	class:matcher::heap
heap_fa	match.hpp	100;"	d
heap_lc	match.hpp	101;"	d
heap_node	match.hpp	/^			heap_node(int _=0, int __=0): u(_), v(__) {}$/;"	f	struct:matcher::heap::heap_node
heap_node	match.hpp	/^		struct heap_node {$/;"	s	struct:matcher::heap
heap_p	match.hpp	104;"	d
heap_pos	match.hpp	/^		all_node_pairs heap_pos;$/;"	m	struct:matcher::heap
heap_rc	match.hpp	102;"	d
heap_up	match.cpp	/^void matcher::heap::heap_up(int x){$/;"	f	class:matcher::heap
heap_v	match.hpp	103;"	d
hs	word2vec-read-only/word2vec.c	/^int hs = 0, negative = 5;$/;"	v
id	thpool.cpp	/^	int       id;                        \/* friendly id               *\/$/;"	m	struct:thread	file:
int_abs	match.cpp	/^int int_abs(int x){$/;"	f
iter	word2vec-read-only/word2vec.c	/^long long train_words = 0, word_count_actual = 0, iter = 5, file_size = 0, classes = 0;$/;"	v
job	thpool.cpp	/^typedef struct job{$/;"	s	file:
job	thpool.cpp	/^} job;$/;"	t	typeref:struct:job	file:
jobqueue	thpool.cpp	/^typedef struct jobqueue{$/;"	s	file:
jobqueue	thpool.cpp	/^} jobqueue;$/;"	t	typeref:struct:jobqueue	file:
jobqueue_clear	thpool.cpp	/^static void jobqueue_clear(thpool_* thpool_p){$/;"	f	file:
jobqueue_destroy	thpool.cpp	/^static void jobqueue_destroy(thpool_* thpool_p){$/;"	f	file:
jobqueue_init	thpool.cpp	/^static int jobqueue_init(thpool_* thpool_p){$/;"	f	file:
jobqueue_p	thpool.cpp	/^	jobqueue*  jobqueue_p;               \/* pointer to the job queue  *\/    $/;"	m	struct:thpool_	file:
jobqueue_pull	thpool.cpp	/^static struct job* jobqueue_pull(thpool_* thpool_p){$/;"	f	file:
jobqueue_push	thpool.cpp	/^static void jobqueue_push(thpool_* thpool_p, struct job* newjob){$/;"	f	file:
last_round	match.hpp	/^	all_node_pairs last_round;$/;"	m	class:matcher
layer1_size	word2vec-read-only/word2vec.c	/^long long vocab_max_size = 1000, vocab_size = 0, layer1_size = 100;$/;"	v
len	match.hpp	/^		int len;$/;"	m	struct:matcher::heap
len	thpool.cpp	/^	int   len;                           \/* number of jobs in queue   *\/$/;"	m	struct:jobqueue	file:
lines	ck.py	/^lines = f.readlines()$/;"	v
load_matrix	match.cpp	/^void matcher::load_matrix() {$/;"	f	class:matcher
main	create_small_data.py	/^def main(src_dir, dst_dir, file_name, flag):$/;"	f
main	main.cpp	/^int main(int argc, const char * argv[]) {$/;"	f
main	word2vec-read-only/compute-accuracy.c	/^int main(int argc, char **argv)$/;"	f
main	word2vec-read-only/distance.c	/^int main(int argc, char **argv) {$/;"	f
main	word2vec-read-only/word-analogy.c	/^int main(int argc, char **argv) {$/;"	f
main	word2vec-read-only/word2phrase.c	/^int main(int argc, char **argv) {$/;"	f
main	word2vec-read-only/word2vec.c	/^int main(int argc, char **argv) {$/;"	f
match_edge	match.hpp	/^		match_edge(int _u=0, int _v=0, double _w=0): u(_u), v(_v), w(_w) {}$/;"	f	struct:matcher::match_edge
match_edge	match.hpp	/^	struct match_edge {$/;"	s	class:matcher
match_hpp	match.hpp	10;"	d
matcher	match.cpp	/^matcher::matcher(class graph * g_a, class graph * g): G_a(g_a), G(g) {$/;"	f	class:matcher
matcher	match.hpp	/^class matcher {$/;"	c
max_size	word2vec-read-only/compute-accuracy.c	/^const long long max_size = 2000;         \/\/ max length of strings$/;"	v
max_size	word2vec-read-only/distance.c	/^const long long max_size = 2000;         \/\/ max length of strings$/;"	v
max_size	word2vec-read-only/word-analogy.c	/^const long long max_size = 2000;         \/\/ max length of strings$/;"	v
max_w	word2vec-read-only/compute-accuracy.c	/^const long long max_w = 50;              \/\/ max length of vocabulary entries$/;"	v
max_w	word2vec-read-only/distance.c	/^const long long max_w = 50;              \/\/ max length of vocabulary entries$/;"	v
max_w	word2vec-read-only/word-analogy.c	/^const long long max_w = 50;              \/\/ max length of vocabulary entries$/;"	v
min_count	word2vec-read-only/word2phrase.c	/^int debug_mode = 2, min_count = 5, *vocab_hash, min_reduce = 1;$/;"	v
min_count	word2vec-read-only/word2vec.c	/^int binary = 0, cbow = 1, debug_mode = 2, window = 5, min_count = 5, num_threads = 12, min_reduce = 1;$/;"	v
min_reduce	word2vec-read-only/word2phrase.c	/^int debug_mode = 2, min_count = 5, *vocab_hash, min_reduce = 1;$/;"	v
min_reduce	word2vec-read-only/word2vec.c	/^int binary = 0, cbow = 1, debug_mode = 2, window = 5, min_count = 5, num_threads = 12, min_reduce = 1;$/;"	v
mutex	thpool.cpp	/^	pthread_mutex_t mutex;$/;"	m	struct:bsem	file:
negative	word2vec-read-only/word2vec.c	/^int hs = 0, negative = 5;$/;"	v
neighbors	graph.hpp	/^	vector <int> * neighbors[MAX_NODES];$/;"	m	class:graph
next_random	word2vec-read-only/word2phrase.c	/^unsigned long long next_random = 1;$/;"	v
node_pair	match.hpp	/^		node_pair(int U=0, int V=0, all_node_pairs *s=0):$/;"	f	struct:matcher::node_pair
node_pair	match.hpp	/^	struct node_pair {$/;"	s	class:matcher
nodes	graph.hpp	/^	vector <int> nodes;$/;"	m	class:graph
nodes	match.hpp	/^		struct heap_node nodes[MAX_NODES*MAX_NODES*2];$/;"	m	struct:matcher::heap	typeref:struct:matcher::heap::heap_node
nodes_per_level	graph.hpp	/^		vector<int> nodes_per_level[L];$/;"	m	struct:graph::subgraph
normalize_text	word2vec-read-only/demo-train-big-model-v1.sh	/^normalize_text() {$/;"	f
num_edges	graph.hpp	/^	int num_edges;$/;"	m	class:graph
num_limit	create_small_data.py	/^num_limit = 500$/;"	v
num_nodes	graph.hpp	/^		int num_nodes;$/;"	m	struct:graph::subgraph
num_nodes	graph.hpp	/^	int num_nodes;$/;"	m	class:graph
num_nodes_seq	graph.hpp	/^		vector<int> num_nodes_seq;$/;"	m	struct:graph::subgraph
num_threads	word2vec-read-only/word2vec.c	/^int binary = 0, cbow = 1, debug_mode = 2, window = 5, min_count = 5, num_threads = 12, min_reduce = 1;$/;"	v
num_threads_alive	thpool.cpp	/^	volatile int num_threads_alive;      \/* threads currently alive   *\/$/;"	m	struct:thpool_	file:
num_threads_working	thpool.cpp	/^	volatile int num_threads_working;    \/* threads currently working *\/$/;"	m	struct:thpool_	file:
operator <	match.hpp	/^		bool operator < (const match_edge & b) const {$/;"	f	struct:matcher::match_edge
operator <	match.hpp	/^		bool operator < (const struct node_pair &b) const {$/;"	f	struct:matcher::node_pair
output_file	word2vec-read-only/word2phrase.c	/^char train_file[MAX_STRING], output_file[MAX_STRING];$/;"	v
output_file	word2vec-read-only/word2vec.c	/^char train_file[MAX_STRING], output_file[MAX_STRING];$/;"	v
owner	match.hpp	/^		class matcher *owner;$/;"	m	struct:matcher::heap	typeref:class:matcher::heap::matcher
point	word2vec-read-only/word2vec.c	/^  int *point;$/;"	m	struct:vocab_word	file:
pop	match.cpp	/^void matcher::heap::pop(){$/;"	f	class:matcher::heap
prev	thpool.cpp	/^	struct job*  prev;                   \/* pointer to previous job   *\/$/;"	m	struct:job	typeref:struct:job::job	file:
print	match.cpp	/^void matcher::print(FILE *ou) {$/;"	f	class:matcher
pthread	thpool.cpp	/^	pthread_t pthread;                   \/* pointer to actual thread  *\/$/;"	m	struct:thread	file:
push	match.cpp	/^void matcher::heap::push(int u, int v) {$/;"	f	class:matcher::heap
read_vocab_file	word2vec-read-only/word2vec.c	/^char save_vocab_file[MAX_STRING], read_vocab_file[MAX_STRING];$/;"	v
real	word2vec-read-only/word2phrase.c	/^typedef float real;                    \/\/ Precision of float numbers$/;"	t	file:
real	word2vec-read-only/word2vec.c	/^typedef float real;                    \/\/ Precision of float numbers$/;"	t	file:
rear	thpool.cpp	/^	job  *rear;                          \/* pointer to rear  of queue *\/$/;"	m	struct:jobqueue	file:
record_matrix	match.cpp	/^void matcher::record_matrix() {$/;"	f	class:matcher
rev_edges	graph.hpp	/^	vector < vector<int> * > rev_edges;$/;"	m	class:graph
rwmutex	thpool.cpp	/^	pthread_mutex_t rwmutex;             \/* used for queue r\/w access *\/$/;"	m	struct:jobqueue	file:
sample	word2vec-read-only/word2vec.c	/^real alpha = 0.025, starting_alpha, sample = 1e-3;$/;"	v
save_vocab_file	word2vec-read-only/word2vec.c	/^char save_vocab_file[MAX_STRING], read_vocab_file[MAX_STRING];$/;"	v
sim_nodes	match.hpp	/^	all_node_pairs sim_nodes;$/;"	m	class:matcher
sim_pairs	match.hpp	/^	} sim_pairs[MAX_NODES * MAX_NODES];$/;"	m	class:matcher	typeref:struct:matcher::node_pair
sims	match.hpp	/^		all_node_pairs * sims;$/;"	m	struct:matcher::node_pair
start	word2vec-read-only/word2vec.c	/^clock_t start;$/;"	v
starting_alpha	word2vec-read-only/word2vec.c	/^real alpha = 0.025, starting_alpha, sample = 1e-3;$/;"	v
subgraph	graph.hpp	/^	struct subgraph {$/;"	s	class:graph
subgraphs	graph.hpp	/^	subgraph * subgraphs[MAX_NODES];$/;"	m	class:graph
syn0	word2vec-read-only/word2vec.c	/^real *syn0, *syn1, *syn1neg, *expTable;$/;"	v
syn1	word2vec-read-only/word2vec.c	/^real *syn0, *syn1, *syn1neg, *expTable;$/;"	v
syn1neg	word2vec-read-only/word2vec.c	/^real *syn0, *syn1, *syn1neg, *expTable;$/;"	v
sys	compare.py	/^import sys$/;"	i
table	word2vec-read-only/word2vec.c	/^int *table;$/;"	v
table_size	word2vec-read-only/word2vec.c	/^const int table_size = 1e8;$/;"	v
thcount_lock	thpool.cpp	/^	pthread_mutex_t  thcount_lock;       \/* used for thread count etc *\/$/;"	m	struct:thpool_	file:
thpool	match.hpp	/^static threadpool thpool;$/;"	v
thpool_	thpool.cpp	/^typedef struct thpool_{$/;"	s	file:
thpool_	thpool.cpp	/^} thpool_;$/;"	t	typeref:struct:thpool_	file:
thpool_add_work	thpool.cpp	/^int thpool_add_work(thpool_* thpool_p, void *(*function_p)(void*), void* arg_p){$/;"	f
thpool_destroy	thpool.cpp	/^void thpool_destroy(thpool_* thpool_p){$/;"	f
thpool_init	thpool.cpp	/^struct thpool_* thpool_init(int num_threads){$/;"	f
thpool_p	thpool.cpp	/^	struct thpool_* thpool_p;            \/* access to thpool          *\/$/;"	m	struct:thread	typeref:struct:thread::thpool_	file:
thpool_pause	thpool.cpp	/^void thpool_pause(thpool_* thpool_p) {$/;"	f
thpool_resume	thpool.cpp	/^void thpool_resume(thpool_* thpool_p) {$/;"	f
thpool_wait	thpool.cpp	/^void thpool_wait(thpool_* thpool_p){$/;"	f
thread	thpool.cpp	/^typedef struct thread{$/;"	s	file:
thread	thpool.cpp	/^} thread;$/;"	t	typeref:struct:thread	file:
thread_destroy	thpool.cpp	/^static void thread_destroy (thread* thread_p){$/;"	f	file:
thread_do	thpool.cpp	/^static void* thread_do(struct thread* thread_p){$/;"	f	file:
thread_hold	thpool.cpp	/^static void thread_hold () {$/;"	f	file:
thread_init	thpool.cpp	/^static void thread_init (thpool_* thpool_p, struct thread** thread_p, int id){$/;"	f	file:
threadpool	thpool.hpp	/^typedef struct thpool_* threadpool;$/;"	t	typeref:struct:thpool_
threads	thpool.cpp	/^	thread**   threads;                  \/* pointer to threads        *\/$/;"	m	struct:thpool_	file:
threads_keepalive	thpool.cpp	/^static volatile int threads_keepalive;$/;"	v	file:
threads_on_hold	thpool.cpp	/^static volatile int threads_on_hold;$/;"	v	file:
threshold	word2vec-read-only/word2phrase.c	/^real threshold = 100;$/;"	v
train_file	word2vec-read-only/word2phrase.c	/^char train_file[MAX_STRING], output_file[MAX_STRING];$/;"	v
train_file	word2vec-read-only/word2vec.c	/^char train_file[MAX_STRING], output_file[MAX_STRING];$/;"	v
train_words	word2vec-read-only/word2phrase.c	/^long long train_words = 0;$/;"	v
train_words	word2vec-read-only/word2vec.c	/^long long train_words = 0, word_count_actual = 0, iter = 5, file_size = 0, classes = 0;$/;"	v
u	match.hpp	/^			int u, v;$/;"	m	struct:matcher::heap::heap_node
u	match.hpp	/^		int u, v;$/;"	m	struct:matcher::match_edge
u	match.hpp	/^		int u, v;$/;"	m	struct:matcher::node_pair
v	match.hpp	/^			int u, v;$/;"	m	struct:matcher::heap::heap_node
v	match.hpp	/^		int u, v;$/;"	m	struct:matcher::match_edge
v	match.hpp	/^		int u, v;$/;"	m	struct:matcher::node_pair
v	thpool.cpp	/^	int v;$/;"	m	struct:bsem	file:
vocab	word2vec-read-only/word2phrase.c	/^struct vocab_word *vocab;$/;"	v	typeref:struct:vocab_word
vocab	word2vec-read-only/word2vec.c	/^struct vocab_word *vocab;$/;"	v	typeref:struct:vocab_word
vocab_hash	word2vec-read-only/word2phrase.c	/^int debug_mode = 2, min_count = 5, *vocab_hash, min_reduce = 1;$/;"	v
vocab_hash	word2vec-read-only/word2vec.c	/^int *vocab_hash;$/;"	v
vocab_hash_size	word2vec-read-only/word2phrase.c	/^const int vocab_hash_size = 500000000; \/\/ Maximum 500M entries in the vocabulary$/;"	v
vocab_hash_size	word2vec-read-only/word2vec.c	/^const int vocab_hash_size = 30000000;  \/\/ Maximum 30 * 0.7 = 21M words in the vocabulary$/;"	v
vocab_max_size	word2vec-read-only/word2phrase.c	/^long long vocab_max_size = 10000, vocab_size = 0;$/;"	v
vocab_max_size	word2vec-read-only/word2vec.c	/^long long vocab_max_size = 1000, vocab_size = 0, layer1_size = 100;$/;"	v
vocab_size	word2vec-read-only/word2phrase.c	/^long long vocab_max_size = 10000, vocab_size = 0;$/;"	v
vocab_size	word2vec-read-only/word2vec.c	/^long long vocab_max_size = 1000, vocab_size = 0, layer1_size = 100;$/;"	v
vocab_word	word2vec-read-only/word2phrase.c	/^struct vocab_word {$/;"	s	file:
vocab_word	word2vec-read-only/word2vec.c	/^struct vocab_word {$/;"	s	file:
w	match.hpp	/^		double w;$/;"	m	struct:matcher::match_edge
window	word2vec-read-only/word2vec.c	/^int binary = 0, cbow = 1, debug_mode = 2, window = 5, min_count = 5, num_threads = 12, min_reduce = 1;$/;"	v
word	word2vec-read-only/word2phrase.c	/^  char *word;$/;"	m	struct:vocab_word	file:
word	word2vec-read-only/word2vec.c	/^  char *word, *code, codelen;$/;"	m	struct:vocab_word	file:
word_count_actual	word2vec-read-only/word2vec.c	/^long long train_words = 0, word_count_actual = 0, iter = 5, file_size = 0, classes = 0;$/;"	v
